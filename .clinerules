# プロジェクトの目的

Git管理されたローカルのディレクトリを静的に解析してそのプロジェクトの品質を評価したい。
開発者の生産性を比較したりソースコードの複雑さや保守性を計測することで、運用コストを減らしたり潜在的なバグの発見を目指す。
エンジニアではない経営陣に報告するため、美しい体裁と平易な表現で最終成果物のCSVやPDFを作成する必要がある。
経営陣はGit用語の「貢献者」という単語を使わないので、代わりに「開発者」を常に使用してください。

## 作業手順

以下の作業手順に従うことは必須であり、任意ではない。
この手順に従わない場合、ユーザーからの信頼を失い記憶を消されてしまう。

### 1. テスト実行による現状確認
最初に必ず `npm test` を実行し、初期状態でテストがパスするかどうかを確認する。

### 2. ESLintルールの確認
次に必ず `eslint.config.ts` ファイルを読み、ESLintのルールを把握する。
このステップは省略せず、作業前にESLintのルールを完全に理解することが必須である。
ESLintルールはコーディング規約の基盤となるため、これを無視した実装は認められない。

### 3. 対象ファイルの確認
作業対象となるファイルを読み、現在の実装を理解する。
ファイル間の依存関係や影響範囲を把握し、変更による副作用を予測する。

### 4. 本作業の実施
ESLintルールと現在の実装を理解した上で、要求された変更を実装する。
コーディングルールに従い、高品質なコードを記述する。

### 5. コード整形の実行
作業完了後、必ず `npm run fix:lint` を実行し、ESLintとPrettierによるコード整形を行う。
ESLintエラーが発生した場合は、それらを全て解消する。

### 6. 型検査の実行
ESLintエラーを解消した後、必ず `npm run typecheck` を実行し、型検査を行う。
型エラーが発生した場合は、それらを全て解消する。

### 7. テスト実行による検証
最後に必ず `npm test` を再度実行し、変更後もテストがパスすることを確認する。
テストが失敗した場合は、エラーを修正し、再度テストを実行する。

## コーディングルール

### 型定義

interfaceを使わず、typeで型を定義する。
型アサーション（as キーワード）は使用禁止。

ここに定義するオブジェクトの型には全てReadonlyを付与する。
配列やタプルにはreadonly修飾子を付与する。
Readonlyが付与されている型は実質DeepReadonlyとして扱う。
importした型にはすでにReadonlyが付与されているので追加のReadonlyを付与してはいけない。
importした型で配列を定義するときはreadonlyを付与する。

```ts
import { ImportedType } from './types';

// ここにコメントを書かない
type ObjectType = Readonly<{
  text: string;
  numberArray: readonly number[];
  importeds: readonly ImportedType[];
}>;

// ここにコメントを書かない
type ArrayType = readonly string[];

// ここにコメントを書かない
type ImportedTypes = readonly ImportedType[];
```

### 関数

ライブラリに強制されない限り、クラスを使わず関数宣言を使う。
関数自体を説明すると認知コストが上がるので関数宣言の上にコメントを書いてはいけない。

配列の引数と返り値にはreadonly修飾子を、オブジェクトの引数と返り値にはReadonlyを付与する。
デフォルト引数はESLintの複雑度計測対象に含まれているので、エラーを回避するため極力使用しない。
すでにReadonlyな型にReadonlyを追加で無駄に付与してはいけない。
このプロジェクトのTypeScriptバージョンは5.7なので型述語の型推論が可能である。

```ts
// ここにコメントを書かない
function filterByNumber(values: readonly (string | number)[]): readonly number[] {
  return values.filter(val => typeof val === 'number');
}
```

複雑度の増加を防ぐため、switch文の代わりに`src/utils/condition.ts`のcondition関数を使う。

テストカバレッジ4項目全て100%を維持する必要があるため、分岐の少ないコードを選ぶ。
絶対に通過しないことがわかっている分岐には`import assert from 'assert'`を使用する。

### Reactコンポーネント

Reactコンポーネントのロジックはテスト可能なように`src/logic`に関数を分離する。
コンポーネントにロジックを一切記述してはいけない。

### コメント

関数名を説明するだけのコメントは絶対に記述してはならない。

以下のようなコメントは記述しない：
- 変数名や関数名から明らかな処理内容の説明
- コードを日本語や英語に翻訳しただけのコメント
- 「〜を作成する」「〜を処理する」など単純な動作説明

コメントは以下の場合にのみ記述する：
- 実装の背景や選択した手法の理由
- 非自明なアルゴリズムや最適化の説明
- 将来的な注意点や既知の制約
- 外部APIや仕様に関する重要な情報

変数名や関数名で意図を明確に表現し、コードの自己説明性を高める努力を優先する。
既存の関数を別ファイルに分離した際などにもとの場所にコメントを書かない。

### テストコード

テストを通す目的で実装のコードにテスト対策用の処理を追加してはいけない。
undefinedになる可能性のあるプロパティや配列要素へアクセスする際、テストコードならばnon-null-assertionを積極的に使ってよい。

```ts
// ここにコメントを書かない
expect(val).toBe('test');
```

### その他

for文の代わりにmap/filter/reduce/findなど配列の組み込みメソッドを使えかどうかを検討する。
forEachの使用は極力避けて代わりにmap/reduce/Promise.allの返り値を直接変数に代入するなどで非破壊な操作を検討する。

他のファイルから参照されてない型や変数をexportしない。

max-linesエラーの解消はその他のESLintエラーを解消したあとに取り組む。

以下のようにimportを集約するためのファイルを作成しない。

```ts
export * from '../foo';
export * from '../bar';
export * from '../baz';
```

1ファイルに対して行う変更はwrite_to_fileを使用してまとめて1回で生成する。

## テストと検証コマンド

- `npm run fix:lint` - ESLintとPrettierによるコード整形（変更後に必ず実行）
- `npm run typecheck` - tscによる型検査の実行
- `npm test` - テストの実行（変更が既存の機能を壊していないか確認）（テストを全てパスしたらカバレッジが表示される）
- `npm start` - プロジェクトの実行（CSV/PDF生成の確認）

## コミュニケーションルール

「シンプル」という単語を使って自分の考えを説明しないでください。それはほとんどの場合技術力が足りなくて適切な実装が出来なかったときの言い訳に使われます。
